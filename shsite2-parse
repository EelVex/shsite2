#!/usr/bin/env bash

###########################
#
#    Use keys of $<n> to parse $<n+1>, start from n=1
#    If only one argument given, get second file from stdin (waits for EOF)
#
#
###########################

###########################
##  simple helper functions {{{

shsite2-parse-help() {
	echo "parse <file-keys> [ <file-keys> ...] <file-parse>"
	echo "parse <file-keys> < <file-parse>"
}

# }}}

shsite2-parse-do() { # {{{
	file_keys=$1
	file_parse=$2
	block_count=1;advance=0
	while [[ $block_count -le $(grep -o '%{' $file_parse | wc -l) ]]
	do

		###########################
		##   Find next block {{{


		block=$($SHS2_PATH/bin/shsite2_blocks $block_count $file_parse)


		# }}}

		###########################
		##   Replace block

		## What is this block?
		btype=${block:0:1}; block=${block:1};
		case $btype in

			# if it is a command (!), execute and replace by output {{{
			"!") 
				command=${block%%:*}
				data=${block#*:}
				# if command exists run it and replace with output
				if [[ $(shsite2 parse-commands -v $command) = "0" ]]; then
					# Successful commands may eliminate some %{...}%s so we have to reset the
					# counter, to just before the command. Do this by counting closing }%s up
					# to this point.
					nbl=$(sed -ne '1,/%{!'$command'/{s/%{!'$command'.*//g;s/}%/}%\n/g;p}' $file_parse | grep -c }%)
					advance=$((nbl-block_count+1))
					# Run command
					shsite2 parse-commands $command "$data" > $file_block_output
				# if not, just output the data and warn (stderr)
				else
					echo -n "($command): $data" > $file_block_output
					echo "parse-command \"$command\" not found" >&2
				fi
			;; # }}}

			# if it is a file (@), replace by file-contents {{{
			"@") 
				echo "file:$block" > $file_block_output
				( [[ -e "$block" ]] && (cp $block $file_block_output) ) || # search in relative-to-current directory first
					( [[ -e "$USER_INC_PATH/$block" ]] && (cp $USER_INC_PATH/$block $file_block_output) ) || # then in user's includes
					( [[ -e "$SHS2_LIB_PATH/$block" ]] && (cp $SHS2_LIB_PATH/$block $file_block_output) ) # then in shs2 library 
			;; # }}}

			# all other cases: it is a key or function, replace by its value/output {{{
			# if no key found in $file_keys, leave the block as is
			* ) 
				block=$btype$block
				key=$(echo $block) # No multiline variable definition for now
				if [[ $(echo "$key" | grep -c '^[^:]*: ') -gt 0 ]]; then
					## If the variable is of the form "var: ...", treat the part after ": "
					## as arguments to the function "var"
					fun="${key%%: *}"
					args=${key#*: }
					body=$($SHS2_PATH/shsite2-get-key $file_keys $fun)
					if [[ -z "$body" ]]; then
					# if key not found, let the block be 
						echo -n "%{$block}%" > $file_block_output;
						advance=1;
					else
						# Successful functions also may eliminate some %{...}%s so we have to reset the
						# counter, to just before the function call. Do this by counting closing }%s up
						# to this point.
						nbl=$(sed -ne '1,/%{'$fun'/{s/%{'$fun'.*//g;s/}%/}%\n/g;p}' $file_parse | grep -c }%)
						advance=$((nbl-block_count+1))
						(
						eval "set $args" 2> /dev/null ||  		# If this fails, 
							eval "set $(printf "%q" "$args")" 	# then escape the string and set it as one argument
						eval "$body" > $file_block_output 2> /dev/null || # If this fails, 
						# then expand variables and output body (perhaps for later evaluation)
						{
							for i in $(seq $#); do
								body=${body//\$$i/${!i}}
							done
							echo "$body" > $file_block_output 		
						}
						)
					fi
				else
					## else, just replace the variable with its value
					$SHS2_PATH/shsite2-get-key $file_keys $key > $file_block_output || 
					# if key not found, let the block be 
					{
						echo -n "%{$block}%" > $file_block_output;
						advance=1;
					}
				fi
			;; # }}}

		esac

		## Put the the output where the block was

		$SHS2_PATH/bin/shsite2_block-put $file_block_output $block_count $file_parse > $file_tmp
		cp $file_tmp $file_parse

		((block_count+=advance))
		advance=0

	done
}

# }}}

###########################
##   INIT {{{

[[ $# -lt 1 ]] && shsite2-parse-help && exit 1

file_parse=`mktemp -t shsite2.XXXXXX`
file_keys=`mktemp -t shsite2.XXXXXX`
file_block_output=`mktemp -t shsite2.XXXXXX`
file_tmp=`mktemp -t shsite2.XXXXXX`

trap "rm -f $file_parse $file_keys $file_block_output $file_tmp" EXIT

# previous $file_parse is the next $file_keys
# so first $file_parse is $1
cp $1 $file_parse

# }}}

## If got just one argument: {{{

[[ $# -eq 1 ]] && {
	cat <&0 > $file_parse;
	shsite2-parse-do "$1" "$file_parse";
}

# }}}

## If got more than two arguments {{{

while [[ $# -ge 2 ]]
do
	cp $file_parse $file_keys # previous parse is new keys
	cp $2 $file_parse	# next arg is new parse

	shsite2-parse-do "$file_keys" "$file_parse"

	shift
done

# }}}


cat $file_parse
